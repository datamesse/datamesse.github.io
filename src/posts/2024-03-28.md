---
title: Using ChatGPT to create a plain text Python encryption tool for password protection
tech: PYTHON
tag: logo-python
date: 28 March 2024
---

This post shows how to use ChatGPT (**[https://chat.openai.com/](https://chat.openai.com/)**) to create a basic Windows desktop application to encrypt plain text data with Python. Inspired by my knowing someone who still uses Notepad to store username and passwords even though they have a proper password management tool.

The reason we are encoding an entire file-like body of text is to appeal to the preferred ease of using something similar to Notepad, as opposed to a password management tool which typically separates out records per credential set.

**Disclaimer**: I am far from any kind of security expert, though understand it is unsafe to leave passwords lying around in plain text files. So whilst any kind of safety measure is better than nothing, this blog post's example is rudimentary, and I would recommend using at least open source tools like KeePass which are actually robust security-wise.

##  Overview of ChatGPT conversation

I listed my requirements, keeping their number small because from experience, asking for too many at once resulted in ChatGPT simply not coding them and my having to explicitly remind it to code those features later.

![ChatGPT: Request for Python code iteration 1](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--01.png?raw=true)

The first result works fine, but the buttons are misaligned. We need them along the top of the application.

![Visual Studio Code: Testing Python code iteration 1](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--02.png?raw=true)

With a bit more fine-tuning asked of GPT for a colour change and for the textbox's horizontal and vertical scrollbars, we get the final result below.

![Visual Studio Code: Testing Python code iteration 2](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--03.png?raw=true)

One of my original requirements involved having the application self-terminate in the event of the password or encryption passphrase typed by the user not matching the file, but I realised;

* That requirement needs Command Prompt to open to facilitate the auto-closure. This goes against the intended standalone executable requirement.

* A malicious party could try to brute force decrypt the JSON file directly, rather than via the application.

Next let's look at how to compile the executable.


## Step 1. Install Python, create a virtual environment, and install libraries

Install Python and the Python Extension for Visual Studio Code.
* **[https://www.python.org/downloads/windows/](https://www.python.org/downloads/windows/)**

Create a folder for your Python project and open it in Visual Studio Code. In this example, the folder name is *lock* is in a subfolder of C:\Project.

Create your virtual environment as a subfolder of your project.

```
python -m venv C:\Project\lock\venv
```

Then ensure it is activated.

![Visual Studio Code: Create and activate virtual environment](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--04.png?raw=true)

You can find more detailed screenshot steps of the above from a previous blog post:
* **[Add forecasts from Python using Visual Studio Code to Power BI](https://datamesse.github.io/#/post/1650117600)**

From within the Python virtual environment, install the required dependencies for the script via a Command Prompt terminal.

```
pip install cryptography
pip install pyinstaller
```

![Visual Studio Code: Install libraries](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--05.png?raw=true)


## Step 2. Create a new Python file and add the script

Create a new Python file in your project's directory and name it lock.py then populate it with the following code.

```
import base64
import json
import tkinter as tk
from tkinter import filedialog, messagebox, simpledialog
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC

class Application(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Text file encryption")

        # Set background color with alpha (semi-transparent black)
        self.config(bg="#D3D3D3")  # Alpha value: 0.9 (Hex: #000000, 90% opacity)

        # Frame for buttons
        button_frame = tk.Frame(self, bg="#181818")  # Set the frame background to match the window background
        button_frame.grid(row=0, column=0, columnspan=2, sticky="ew")

        self.open_button = tk.Button(button_frame, text="Open", command=self.open_file, bg="#000000", fg="#FFFFFF")
        self.open_button.grid(row=0, column=0)

        self.save_button = tk.Button(button_frame, text="Save", command=self.save_file, bg="#000000", fg="#FFFFFF")
        self.save_button.grid(row=0, column=1)

        # Textbox without word wrapping
        self.textbox = tk.Text(self, wrap="none", bg="#181818", fg="#FFFFFF")  # Set background to semi-transparent black and text color to white
        self.textbox.grid(row=1, column=0, sticky="nsew")

        # Vertical scrollbar
        scrollbar_y = tk.Scrollbar(self, orient="vertical", command=self.textbox.yview)
        scrollbar_y.grid(row=1, column=1, sticky="ns")
        self.textbox.config(yscrollcommand=scrollbar_y.set)

        # Horizontal scrollbar
        scrollbar_x = tk.Scrollbar(self, orient="horizontal", command=self.textbox.xview)
        scrollbar_x.grid(row=2, column=0, sticky="ew")
        self.textbox.config(xscrollcommand=scrollbar_x.set)

        # Configure row and column weights
        self.rowconfigure(1, weight=1)
        self.columnconfigure(0, weight=1)

    def save_file(self):
        text_data = self.textbox.get("1.0", "end-1c")
        if not text_data:
            messagebox.showwarning("Warning", "No data to save.")
            return

        passphrase = self.prompt_passphrase("Enter encryption passphrase")
        if not passphrase:
            return

        password = self.prompt_password("Enter password for file")
        if not password:
            return

        iterations = self.prompt_iterations("Enter number of iterations")
        if not iterations:
            return

        key = self.derive_key(passphrase, iterations)
        fernet = Fernet(key)
        encrypted_password = fernet.encrypt(password.encode())
        encrypted_text_data = fernet.encrypt(text_data.encode())

        file_path = filedialog.asksaveasfilename(defaultextension=".json")
        if file_path:
            with open(file_path, "w") as file:
                json.dump({"password": encrypted_password.decode(), "text_data": encrypted_text_data.decode()}, file)


    def open_file(self):
        file_path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])
        if not file_path:
            return

        passphrase = self.prompt_passphrase("Enter decryption passphrase")
        if not passphrase:
            return

        password = self.prompt_password("Enter password for file")
        if not password:
            return

        iterations = self.prompt_iterations("Enter number of iterations")
        if not iterations:
            return

        try:
            with open(file_path, "r") as file:
                data = json.load(file)

            key = self.derive_key(passphrase, iterations)
            fernet = Fernet(key)
            decrypted_password = fernet.decrypt(data["password"].encode()).decode()

            if password != decrypted_password:
                messagebox.showwarning("Warning", "Incorrect password.")
                return

            decrypted_text_data = fernet.decrypt(data["text_data"].encode()).decode()
            self.textbox.delete("1.0", "end")
            self.textbox.insert("1.0", decrypted_text_data)
        except Exception as e:
            messagebox.showerror("Error", "Failed to open file.")

    def prompt_passphrase(self, message):
        self.withdraw()  # Hide the main window temporarily
        passphrase = simpledialog.askstring("Passphrase", message, show='*')
        self.deiconify()  # Restore the main window
        return passphrase

    def prompt_password(self, message):
        self.withdraw()  # Hide the main window temporarily
        password = simpledialog.askstring("Password", message, show='*')
        self.deiconify()  # Restore the main window
        return password

    def prompt_iterations(self, message):
        self.withdraw()  # Hide the main window temporarily
        iterations = simpledialog.askstring("Iterations", message, show='*')
        self.deiconify()  # Restore the main window
        return iterations

    def derive_key(self, passphrase, iterations):
        backend = default_backend()
        salt = b'salt_123'
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=int(iterations),
            backend=backend
        )
        key = kdf.derive(passphrase.encode())
        return base64.urlsafe_b64encode(key)

if __name__ == "__main__":
    app = Application()
    app.mainloop()

```


## Step 3. Compile the script as a standalone executable

From the Command Prompt terminal, run the following command:

```
pyinstaller --onefile --noconsole lock.py
```

The --onefile parameter generates a single .exe executable, and --noconsole prevents a Command Prompt from opening when the application is executed assuming the code does not require it.

This creates a dist subfolder in the project directory where the executable is generated.

![Visual Studio Code: Python code compilation](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--06.png?raw=true)


## Step 4. Testing the application

From File Explorer double-click the lock.exe application.

Type or copy-and-paste the information you would like to encrypt, then click Save.

![Lock: Type information then Save button](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--07.png?raw=true)

Type the passphrase used to generate the encryption key for the algorithm.

![Lock: Type Passphrase then OK](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--08.png?raw=true)

Type the password to encrypt the file.

![Lock: Type Password then OK](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--09.png?raw=true)

Type the number of iterations for the algorithm to perform for the encryption.

![Lock: Type Iterations then OK](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--10.png?raw=true)

Provide a name and location for the encrypted file.

![Lock: Save](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--11.png?raw=true)

When you open the generated file in Notepad, you can see that it is encrypted.

![Encrypted file contents](https://raw.githubusercontent.com/datamesse/datamesse.github.io/main/src/assets-blog/2024-03-28--12.png?raw=true)

You will need to memorise all 3 security components; passphrase, iterations, and password to decrypt the file using the Open button. Each file you save can have its own unique set.


**Key note**

Windows Defender and other antivirus software will delete this executable from your system. So far I've found keeping it zipped helps prevent that deletion as one free means. Otherwise, you may need to look into paid methods of digitally signing the application.


### References

* **[ChatGPT 3.5](https://chat.openai.com/)**

Click **[here](https://github.com/datamesse/datamesse.github.io/blob/main/src/posts/2024-03-28.md)** for this post's markdown file in GitHub.